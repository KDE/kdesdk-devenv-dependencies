#!/usr/bin/env python3

import argparse
import sys
import shutil
import subprocess
import operator
from enum import Enum
from functools import reduce
import concurrent.futures
import json

import gi
gi.require_version('PackageKitGlib', '1.0')
from gi.repository import PackageKitGlib as packagekit

client = packagekit.Client()

neededFiles = [
    "Qt5CoreConfig.cmake",
    "Qt5QuickConfig.cmake",
    "Qt5WebEngineConfig.cmake",

    "ECMConfig.cmake",
    "KF5XmlGuiConfig.cmake",
    "KF5SolidConfig.cmake",
    "KF5DeclarativeConfig.cmake",
    "KF5KirigamiConfig.cmake" ]

neededBinaries =  [
    "gcc",
    "g++",
    "cmake",
    "cmake-gui",
    "git",
    "gdb",
    "clang",
    "make",
    "ninja",
    #"clazy",
]

suggestedBinaries = [
    "plasmaengineexplorer",
    "plasmawindowed",
    "cuttlefish",
    "kate",
    "kdevelop"
]

def progressCallback(progress, type, user_data):
    pass
    #print('  ', type.value_name, 'package:', progress.props.package_id, ':', progress.props.percentage, '%')


class RequirementType(Enum):
    Needed = 0
    Suggested = 1


class Global:
    debArchitecture = None

    packages = {}
    packagesNotFound = []

    def __init__(self):
        values  = [ (v, RequirementType.Needed, False) for v in neededFiles]
        values += [ (v, RequirementType.Needed, True)  for v in neededBinaries]
        values += [ (v, RequirementType.Suggested, True)  for v in suggestedBinaries]

        self.process(values)

    def addResults(self, fileName, req, pkgs):
        if not pkgs:
            self.packagesNotFound.append(v)
        else:
            for p in pkgs:
                self.packages[p] = (req, fileName)

    def printVerbose(self):
        if self.packagesNotFound:
            print("Could not find packages for", self.packagesNotFound)
            print()

        print("We suggest the following packages:")
        for pkg, props in self.packages:
            print("* ", pkg, "<-", props)

    def printPackagesJson(self):
        ret = {
            "required": [],
            "suggested": []
        }
        for pkg, (required, filename) in self.packages.items():
            if required == RequirementType.Needed:
                ret["required"].append(pkg)
            else:
                ret["suggested"].append(pkg)
        print(json.dumps(ret, sort_keys=True, indent=4, separators=(',', ': ')))

    def printPackages(self):
        print(" ".join(self.packages.keys()))

    def installPackages(self):
        subprocess.call(["pkcon", "install"] + list(self.packages.keys()))

    def searchFiles(arg):
        (fileName, requirement, isExecutable) = arg
        packages = None

        #ArchLinux
        if shutil.which("pacman"):
            cmd = ["pacman", "-Fs", fileName]
            output = subprocess.check_output(cmd)
            start = output.index(b'/')+1 #extra/gcc -> gcc
            end = output.index(b' ')
            packages = [ output[start:end].decode("utf-8") ] # only use the first alternative, pacman will sort them by repository precedence
        #Debian
        elif shutil.which("apt-file"):
            if not Global.debArchitecture:
                Global.debArchitecture = subprocess.check_output(["dpkg", "--print-architecture"]).decode("utf-8").strip()
            prefix = "^/usr/bin/" if isExecutable else "/"
            fileName = fileName.replace("+", "\+") # prepare for regex
            packages = subprocess.check_output(["apt-file", "search", "--package-only", "-x", prefix + fileName + "$", "--arch", Global.debArchitecture]).decode("utf-8").strip().split()
        #PackageKit
        elif shutil.which("pkcon"):
            result = client.search_files(0, [fileName], None, progressCallback, None)
            packages = [p.get_name() for p in result.get_package_array()]

        return (fileName, requirement, packages)

    def process(self, values):
        with concurrent.futures.ProcessPoolExecutor() as executor:
            #for fileName, req, packages in map(Global.searchFiles, values):
            for fileName, req, packages in executor.map(Global.searchFiles, values):
                if len(packages)>1:
                    print("many packages for %s" % v, packages)
                self.addResults(fileName, req, packages)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("command", help="[install|packages|packages-json|list]")
    parser.add_argument("--verbose", action='store_true', help="increase output verbosity")
    args = parser.parse_args()

    g = Global()

    if args.verbose:
        g.printVerbose()

    if args.command == "install":
        g.installPackages()
    elif args.command == "packages":
        g.printPackages()
    elif args.command == "packages-json":
        g.printPackagesJson()
    else:
        correctCommand = args.command=="list"
        if not correctCommand:
            print("Wrong command '%s'" % args.command)
            print()

        print(" install:  triggers an install of the needed packages.")
        print(" packages: lists the suggested packages, for distributors mostly.")
        print(" list:     this list")
        return 0 if correctCommand else 1

    return 0

if __name__ == "__main__":
    sys.exit(main())
