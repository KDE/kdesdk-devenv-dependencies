#!/usr/bin/env python3
import sys
import shutil
import subprocess
import operator
import concurrent.futures

import gi
gi.require_version('PackageKitGlib', '1.0')
from gi.repository import PackageKitGlib as packagekit

client = packagekit.Client()

neededFiles = [
    "Qt5CoreConfig.cmake",
    "Qt5QuickConfig.cmake",
    "Qt5WebEngineConfig.cmake",

    "ECMConfig.cmake",
    "KF5XmlGuiConfig.cmake",
    "KF5SolidConfig.cmake",
    "KF5DeclarativeConfig.cmake",
    "KF5KirigamiConfig.cmake" ]

neededBinaries =  [
    "gcc",
    "g++",
    "cmake",
    "cmake-gui",
    "git",
    "gdb",
    "clang",
    "make",
    "ninja",
    #"clazy",

    "plasmaengineexplorer",
    "plasmawindowed",
    "cuttlefish",
    "kate",
    "kdevelop"
]

def progressCallback(progress, type, user_data):
    pass
    #print('  ', type.value_name, 'package:', progress.props.package_id, ':', progress.props.percentage, '%')


class Global:
    debArchitecture = None

    packages = {}
    packagesNotFound = []

    def addResults(self, v, pkgs):
        if not pkgs:
            self.packagesNotFound.append(v)
        else:
            for p in pkgs:
                self.packages[p] = v

    def printNow(self):
        if self.packagesNotFound:
            print("Could not find packages for", self.packagesNotFound)
            print()

        print("We suggest the following packages:")
        for pkg in self.packages:
            print("* ", pkg, "<-", self.packages[pkg])

    def searchFiles(arg):
        (fileName, isExecutable) = arg
        packages = None

        #ArchLinux
        if shutil.which("pkgfile"):
            cmd = ["pkgfile", fileName]
            if isExecutable:
                cmd.insert(1, "-b")
            output = subprocess.check_output(cmd)
            idx = output.index(b'\n')
            packages = [ output[:idx].decode("utf-8") ] # only use the first alternative, pkgfile will sort them by repository precedence
        #Debian
        elif shutil.which("apt-file"):
            if not Global.debArchitecture:
                Global.debArchitecture = subprocess.check_output(["dpkg", "--print-architecture"]).decode("utf-8").strip()
            prefix = "^/usr/bin/" if isExecutable else "/"
            fileName = fileName.replace("+", "\+") # prepare for regex
            packages = subprocess.check_output(["apt-file", "search", "--package-only", "-x", prefix + fileName + "$", "--arch", Global.debArchitecture]).decode("utf-8").strip().split()
        #PackageKit
        elif shutil.which("pkcon"):
            result = client.search_files(0, [fileName], None, progressCallback, None)
            packages = [p.get_name() for p in result.get_package_array()]

        return (fileName, packages)

    def process(self, values):
        with concurrent.futures.ProcessPoolExecutor() as executor:
            for v, packages in map(Global.searchFiles, values):
            #for v, packages in executor.map(Global.searchFiles, values):
                if len(packages)>1:
                    print("many packages for %s" % v, packages)
                self.addResults(v, packages)

def main():
    g = Global()
    values  = [ (v, False) for v in neededFiles]
    values += [ (v, True)  for v in neededBinaries]

    g.process(values)

    g.printNow()
    return 0

if __name__ == "__main__":
    sys.exit(main())
